package coroutines

import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

suspend fun main() {
//    withoutCoroutines()
    withCoroutines()
}

suspend fun withoutCoroutines() {
    for (i in 0..5) {
        delay(400L)
        println(i)
    }

    println("Hello Coroutines")
}

suspend fun withCoroutines() = coroutineScope {
    launch {
        for (i in 0..5) {
            delay(400L)
            println(i)
        }
    }

//    println("Hello Coroutines")
}

/** 1.Модификатор suspend определяет функцию, которая может приостановить свое выполнение и возобновить его через некоторый период времени
 * 2.Прежде всего для определения и выполнения корутины нам надо определить для нее контекст, так как корутина может вызываться только в контексте корутины (coroutine scope). Для этого применяется функция coroutineScope() - создает контекст корутины. Кроме того, эта функция ожидает выполнения всех определенных внутри нее корутин. Стоит отметить, что coroutineScope() может применяться только в функции с модификатором suspend, коей является функция main.

Сама корутина определяется и запускается с помощью построителя корутин - функции launch. Она создает корутину в виде блока кода - в данном случае это:
{
for(i in 0..5){
delay(400L)
println(i)
}
}
и запускает эту корутину параллельно с остальным кодом. То есть данная корутина выполняется независимо от прочего кода, определенного в функции main.

Все что находится внутри launch - можно вынести в отдельную функцию и тогда внутри launch будет только вызов данной функции {doWork()}

Важный ньюанс - функция main должна возвращать значение Unit поэтому удаление привести к ошибке, но у меня все отрабатывает нормально
 * */


/** Корутины и потоки
В ряде языков программирования есть такие структуры, которые позволяют использовать потоки. Однако между корутинами и потоками нет прямого соответствия. Корутина не привязана к конкретному потоку. Она может быть приостановить выполнение в одном потоке, а возобновить выполнение в другом.

Когда корутина приостанавливает свое выполнение, например, как в случае выше при вызове задержки с помощью функции delay(), эта корутина освобождает поток, в котором она выполнялась, и сохраняется в памяти. А освобожденный поток может быть зайдествован для других задач. А когда завершается запущенная задача (например, выполнение функции delay()), корутина возобновляет свою работу в одном из свободных потоков.

 * */